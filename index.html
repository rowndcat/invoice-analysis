import React, { useState, useRef, useEffect } from 'react';

// Tailwind CSS is assumed to be available in the project.

const App = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [analysisData, setAnalysisData] = useState(''); 
  const [parsedAnalysisData, setParsedAnalysisData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [fileName, setFileName] = useState('');
  const fileInputRef = useRef(null);
  const [isDragging, setIsDragging] = useState(false);

  const webhookUrl = 'https://aikerrijames.app.n8n.cloud/webhook/9b85467d-a6f4-4ea1-86e3-3098141f3cc9';

  const formatTextToHtml = (plainText) => {
    if (typeof plainText !== 'string') {
      console.warn("formatTextToHtml: input was not a string", plainText);
      return '';
    }
    let htmlText = plainText;
    const escapeDiv = document.createElement('div');
    escapeDiv.textContent = htmlText;
    htmlText = escapeDiv.innerHTML;
    htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    htmlText = htmlText.replace(/__(.*?)__/g, '<strong>$1</strong>');
    htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
    htmlText = htmlText.replace(/_(.*?)_/g, '<em>$1</em>');
    htmlText = htmlText.replace(/\n/g, '<br />');
    return htmlText;
  };

  const parseInvoiceOutput = (outputString = "") => {
    if (typeof outputString !== 'string' || !outputString) {
      return { overallAssessment: '', sections: [] };
    }
    let overallAssessmentText = '';
    const sectionsArray = [];
    const overallAssessmentMarker = "Overall Assessment:";
    const problematicSectionsMarkerRegex = /\n\s*\n?Problematic Sections(?: and Suggested Rewrites)?:/; 
    const problematicSectionsMatch = outputString.match(problematicSectionsMarkerRegex);
    let problematicSectionsStartIndex = problematicSectionsMatch ? problematicSectionsMatch.index : -1;
    let problematicSectionsMarkerActual = problematicSectionsMatch ? problematicSectionsMatch[0] : "";

    if (outputString.startsWith(overallAssessmentMarker)) {
      const endOfOverall = problematicSectionsStartIndex !== -1 ? problematicSectionsStartIndex : outputString.length;
      overallAssessmentText = outputString.substring(overallAssessmentMarker.length, endOfOverall).trim();
    } else if (problematicSectionsStartIndex !== -1) { 
      overallAssessmentText = outputString.substring(0, problematicSectionsStartIndex).trim();
    } else { 
      overallAssessmentText = outputString.trim();
      return { overallAssessment: formatTextToHtml(overallAssessmentText), sections: [] };
    }
    const formattedOverallAssessment = formatTextToHtml(overallAssessmentText);
    if (problematicSectionsStartIndex === -1) {
      return { overallAssessment: formattedOverallAssessment, sections: [] };
    }

    let sectionsText = outputString.substring(problematicSectionsStartIndex + problematicSectionsMarkerActual.length).trim();
    const sectionBlocks = sectionsText.split(/\n\s*\n?(?=\d+\.\s)/).filter(block => block.trim() !== '');

    for (const block of sectionBlocks) {
      const lines = block.split('\n').map(l => l.trim()).filter(l => l);
      if (lines.length === 0) continue;
      const rawTitle = lines[0] || '';
      const currentSection = { 
        title: formatTextToHtml(rawTitle), 
        original: '', originalDetails: '', rewritten: '', explanation: '' 
      };
      let contentBuffer = [];
      let currentContentType = null; 
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const flushBuffer = () => {
          if (contentBuffer.length > 0) {
            let text = contentBuffer.join('\n'); 
            text = text.replace(/^"|"$/g, '');   
            text = text.replace(/^[• \s]+/, ''); 
            text = text.trim();  
            const formattedContent = formatTextToHtml(text);
            if (currentContentType === 'original') currentSection.original = formattedContent;
            else if (currentContentType === 'rewritten') currentSection.rewritten = formattedContent;
            else if (currentContentType === 'explanation') currentSection.explanation = formattedContent;
            contentBuffer = [];
          }
        };
        const originalMatch = line.match(/^[• •]\s*Original:\s*(\(([^)]+)\))?(.*)/);
        const rewrittenMatch = line.match(/^[• •]\s*Rewritten:(.*)/);
        const explanationMatch = line.match(/^[• •]\s*Explanation:(.*)/);
        if (originalMatch) {
          flushBuffer(); currentContentType = 'original';
          currentSection.originalDetails = originalMatch[2] ? originalMatch[2].trim() : '';
          let contentOnLine = originalMatch[3] ? originalMatch[3].trim() : '';
          if (contentOnLine.startsWith('"') && contentOnLine.endsWith('"')) contentOnLine = contentOnLine.substring(1, contentOnLine.length - 1);
          if (contentOnLine) contentBuffer.push(contentOnLine);
        } else if (rewrittenMatch) {
          flushBuffer(); currentContentType = 'rewritten';
          let contentOnLine = rewrittenMatch[1] ? rewrittenMatch[1].trim() : '';
          if (contentOnLine.startsWith('"') && contentOnLine.endsWith('"')) contentOnLine = contentOnLine.substring(1, contentOnLine.length - 1);
          if (contentOnLine) contentBuffer.push(contentOnLine);
        } else if (explanationMatch) {
          flushBuffer(); currentContentType = 'explanation';
          let contentOnLine = explanationMatch[1] ? explanationMatch[1].trim() : '';
          if (contentOnLine.startsWith('"') && contentOnLine.endsWith('"')) contentOnLine = contentOnLine.substring(1, contentOnLine.length - 1);
          if (contentOnLine) contentBuffer.push(contentOnLine);
        } else if (currentContentType) { 
          contentBuffer.push(line.replace(/^[ \s]+/, '')); 
        }
      }
      flushBuffer(); 
      if (rawTitle || currentSection.original || currentSection.rewritten || currentSection.explanation) {
        sectionsArray.push(currentSection);
      }
    }
    return { overallAssessment: formattedOverallAssessment, sections: sectionsArray };
  };

  useEffect(() => {
    if (analysisData) {
      const parsed = parseInvoiceOutput(analysisData);
      setParsedAnalysisData(parsed);
    } else {
      setParsedAnalysisData(null);
    }
  }, [analysisData]);

  const processFile = (file) => {
    if (file && file.type === "application/pdf") {
        setSelectedFile(file);
        setFileName(file.name);
        setError(null);
        setAnalysisData(''); 
        setParsedAnalysisData(null);
    } else {
        setSelectedFile(null);
        setFileName('');
        setError("Invalid file type. Please upload a PDF.");
        if (fileInputRef.current) fileInputRef.current.value = ""; // Reset if invalid file type
    }
  };

  const handleFileChange = (event) => {
    const file = event.target.files[0];
    processFile(file);
  };

  const handleDrop = (event) => {
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    const file = event.dataTransfer.files[0];
    processFile(file);
    if (fileInputRef.current) { // Sync with hidden input for consistency if needed, or manage state directly
        fileInputRef.current.files = event.dataTransfer.files;
    }
  };

  const handleDragOver = (event) => {
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (event) => {
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
  };
  
  const handleSubmitAndAnalyze = async () => {
    if (!selectedFile) {
      setError('Please select a PDF file to upload.');
      return;
    }
    setIsLoading(true);
    setError(null);
    setAnalysisData('');
    setParsedAnalysisData(null);
    const formData = new FormData();
    formData.append('data', selectedFile);
    try {
      const response = await fetch(webhookUrl, { method: 'POST', body: formData });
      if (!response.ok) {
        let errorText = `Error: ${response.status} ${response.statusText}`;
        try { const errorData = await response.json(); errorText = `Error ${response.status}: ${errorData.message || JSON.stringify(errorData)}`; } catch (e) { /* Ignore */ }
        throw new Error(errorText);
      }
      const responseData = await response.json();
      if (responseData && typeof responseData === 'object' && !Array.isArray(responseData) && typeof responseData.output === 'string') {
        setAnalysisData(responseData.output);
      } else {
        console.error("Unexpected data format or type from webhook. Received:", responseData);
        throw new Error(`Unexpected data format or type from webhook. Expected an object with an "output" string property. Received: ${JSON.stringify(responseData)}`);
      }
      setSelectedFile(null);
      setFileName('');
      if (fileInputRef.current) fileInputRef.current.value = "";
    } catch (err) {
      console.error("Upload/Analysis error:", err);
      setError(String(err.message || 'Failed to upload invoice or get analysis.'));
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-indigo-100 py-8 px-4 font-inter flex flex-col items-center justify-center">
      <div className="w-full max-w-xl bg-white p-8 sm:p-10 rounded-xl shadow-2xl">
        <header className="mb-8 text-center">
          <h1 className="text-3xl sm:text-4xl font-bold text-slate-800">Invoice Analysis Tool</h1>
          <p className="text-slate-600 mt-3 text-md sm:text-lg">
            Upload your invoice PDF and get detailed analysis and insights
          </p>
        </header>

        {!parsedAnalysisData && !isLoading && (
          <>
            <div 
              className={`w-full p-6 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors duration-200 ease-in-out
                          ${isDragging ? 'border-indigo-600 bg-indigo-50' : 'border-slate-300 hover:border-indigo-400'}`}
              onClick={() => fileInputRef.current && fileInputRef.current.click()}
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
            >
              <input
                type="file" id="invoicePdf" ref={fileInputRef} onChange={handleFileChange} accept="application/pdf"
                className="hidden"
              />
              <div className="flex flex-col items-center justify-center space-y-3 text-slate-600">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-12 h-12 text-indigo-500">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3 3m3-3l3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.338-2.32 5.75 5.75 0 011.045 11.098A4.502 4.502 0 0118.25 19.5H6.75z" />
                </svg>
                <p className="font-semibold text-indigo-700">Click to upload or drag and drop</p>
                <p className="text-xs">PDF invoices only</p>
                {fileName && <p className="mt-2 text-sm text-slate-500 bg-slate-100 px-3 py-1 rounded-md">{`Selected: ${String(fileName)}`}</p>}
              </div>
            </div>

            {error && !fileName && ( // Only show general error if no file is selected yet
              <div className="mt-4 text-center bg-red-50 border-l-4 border-red-400 text-red-700 p-3 rounded-md shadow text-sm" role="alert">
                <p>{String(error)}</p> 
              </div>
            )}
            
            <button
              onClick={handleSubmitAndAnalyze} 
              disabled={isLoading || !selectedFile}
              className="w-full mt-8 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-400 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-150 ease-in-out"
            >
              {isLoading ? (
                  <div className="flex items-center justify-center">
                      <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                      </svg>
                      Analyzing Invoice...
                  </div>
              ) : (
                  'Analyze Invoice'
              )}
            </button>
          </>
        )}
        
        {isLoading && !parsedAnalysisData && (
             <div className="text-center py-10">
                <svg className="animate-spin mx-auto h-12 w-12 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
                <p className="mt-3 text-slate-600">Analyzing your invoice, please wait...</p>
            </div>
        )}


        {error && parsedAnalysisData && ( // Show error above results if analysis was attempted but failed
             <div className="mb-6 bg-red-50 border-l-4 border-red-400 text-red-700 p-4 rounded-md shadow" role="alert">
                <p className="font-bold">Analysis Error</p>
                <p>{String(error)}</p> 
            </div>
        )}

        {parsedAnalysisData && (
          <div className="mt-0"> {/* Removed top margin if results are shown */}
            <button 
              onClick={() => {
                setParsedAnalysisData(null); 
                setError(null); 
                setFileName(''); 
                setSelectedFile(null);
                if(fileInputRef.current) fileInputRef.current.value = "";
              }}
              className="mb-6 w-full sm:w-auto bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold py-2 px-4 rounded-lg shadow-sm transition-colors text-sm flex items-center justify-center"
            >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-4 h-4 mr-2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" />
                </svg>
                Analyze Another Invoice
            </button>

            <h2 className="text-2xl font-semibold text-slate-700 mb-1">Analysis Report</h2>
            {parsedAnalysisData.overallAssessment && (
              <div className="mt-4 mb-6">
                <h3 className="text-xl font-semibold text-slate-600 mb-2">Overall Summary:</h3>
                <div className="text-sm text-slate-800 leading-relaxed prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: parsedAnalysisData.overallAssessment }} />
              </div>
            )}
            {parsedAnalysisData.sections && parsedAnalysisData.sections.length > 0 && (
              <div>
                <h3 className="text-xl font-semibold text-slate-600 mb-3">Section Review:</h3>
                {parsedAnalysisData.sections.map((section, index) => (
                  <div key={index} className="mb-6 p-4 border border-slate-200 rounded-lg bg-slate-50/50">
                    {section.title && <h4 className="text-md font-semibold text-slate-700 mb-2 prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: section.title }} />}
                    <h5 className="text-sm font-medium text-gray-600 mt-2">Original Description {section.originalDetails ? `(${String(section.originalDetails)})` : ''}:</h5>
                    <div className="text-sm text-gray-800 mt-1 p-2 bg-white rounded border border-slate-100 prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: section.original || "N/A" }} />
                    <h5 className="text-sm font-medium text-gray-600 mt-3">Rewritten:</h5>
                    <div className="text-sm text-gray-800 mt-1 p-2 bg-white rounded border border-slate-100 prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: section.rewritten || "N/A" }} />
                    <h5 className="text-sm font-medium text-gray-600 mt-3">Explanation:</h5>
                    <div className="text-sm text-gray-800 mt-1 p-2 bg-white rounded border border-slate-100 prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: section.explanation || "N/A" }} />
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
        
        {!isLoading && !parsedAnalysisData && !error && !selectedFile && (
             <div className="text-center text-slate-500 pt-6 text-sm">
                <p>Upload a PDF invoice to begin the analysis.</p>
            </div>
        )}
      </div>
    </div>
  );
};

export default App;
